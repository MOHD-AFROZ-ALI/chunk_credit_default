# ============================================================================
# FUNCTION 9.4.4: CREATE CAPITAL ALLOCATION INSIGHTS - PART 2 OF 2
# ============================================================================
# 
# Module: Portfolio Management & Capital Allocation
# Version: 1.0.0
# Created: 2025-06-30 18:26:22
# Author: AI Code Generation Agent
# 
# DESCRIPTION:
# This is Part 2 of the create_capital_allocation_insights() function, focusing on:
# - Portfolio optimization methods (efficient frontier, constraint handling)
# - Advanced analytics and scenario analysis  
# - Regulatory compliance validation
# - Performance benchmarking and reporting
# - Integration function to combine all components
#
# DEPENDENCIES:
# - numpy: For numerical computations and matrix operations
# - pandas: For data manipulation and analysis
# - scipy.optimize: For portfolio optimization algorithms
# - matplotlib: For visualization (if needed)
#
# USAGE:
# create_capital_allocation_insights = create_capital_allocation_insights_part2()
# results = create_capital_allocation_insights(returns_data, asset_metadata, scenarios)
#
# ============================================================================

import numpy as np
import pandas as pd
from scipy.optimize import minimize

def create_capital_allocation_insights_part2():
    """
    Part 2: Portfolio optimization, constraints, and advanced analytics

    Returns:
        function: Complete capital allocation insights function
    """

    class PortfolioOptimizer:
        """
        Portfolio optimization engine using Modern Portfolio Theory

        Features:
        - Efficient frontier calculation
        - Risk-return optimization
        - Constraint handling
        - Sharpe ratio maximization
        """

        def __init__(self, returns_data, risk_free_rate=0.02):
            """
            Initialize portfolio optimizer

            Args:
                returns_data (pd.DataFrame): Historical returns data
                risk_free_rate (float): Risk-free rate for Sharpe ratio calculation
            """
            self.returns = returns_data
            self.risk_free_rate = risk_free_rate
            self.mean_returns = returns_data.mean()
            self.cov_matrix = returns_data.cov()

        def efficient_frontier(self, num_portfolios=100):
            """
            Calculate efficient frontier portfolios

            Args:
                num_portfolios (int): Number of portfolios to calculate

            Returns:
                np.array: Array with returns, risks, and Sharpe ratios
            """
            n_assets = len(self.mean_returns)
            results = np.zeros((3, num_portfolios))

            # Target returns range
            target_returns = np.linspace(self.mean_returns.min(), self.mean_returns.max(), num_portfolios)

            for i, target in enumerate(target_returns):
                # Optimization constraints
                constraints = [
                    {'type': 'eq', 'fun': lambda x: np.sum(x) - 1},  # Weights sum to 1
                    {'type': 'eq', 'fun': lambda x: np.dot(x, self.mean_returns) - target}  # Target return
                ]
                bounds = tuple((0, 1) for _ in range(n_assets))

                # Minimize portfolio variance
                result = minimize(
                    lambda x: np.dot(x.T, np.dot(self.cov_matrix, x)),
                    np.array([1/n_assets] * n_assets),
                    method='SLSQP',
                    bounds=bounds,
                    constraints=constraints
                )

                if result.success:
                    portfolio_return = np.dot(result.x, self.mean_returns)
                    portfolio_risk = np.sqrt(np.dot(result.x.T, np.dot(self.cov_matrix, result.x)))
                    sharpe_ratio = (portfolio_return - self.risk_free_rate) / portfolio_risk

                    results[0, i] = portfolio_return
                    results[1, i] = portfolio_risk
                    results[2, i] = sharpe_ratio

            return results

        def optimize_portfolio(self, target_return=None, risk_tolerance=None):
            """
            Optimize portfolio for specific objectives

            Args:
                target_return (float): Target return constraint
                risk_tolerance (float): Risk tolerance level

            Returns:
                np.array: Optimal portfolio weights
            """
            n_assets = len(self.mean_returns)

            if target_return:
                # Minimize risk for target return
                constraints = [
                    {'type': 'eq', 'fun': lambda x: np.sum(x) - 1},
                    {'type': 'eq', 'fun': lambda x: np.dot(x, self.mean_returns) - target_return}
                ]
                objective = lambda x: np.dot(x.T, np.dot(self.cov_matrix, x))
            else:
                # Maximize Sharpe ratio
                constraints = [{'type': 'eq', 'fun': lambda x: np.sum(x) - 1}]
                objective = lambda x: -(np.dot(x, self.mean_returns) - self.risk_free_rate) / np.sqrt(np.dot(x.T, np.dot(self.cov_matrix, x)))

            bounds = tuple((0, 1) for _ in range(n_assets))
            result = minimize(objective, np.array([1/n_assets] * n_assets), 
                            method='SLSQP', bounds=bounds, constraints=constraints)

            return result.x if result.success else None

    class RegulatoryConstraintValidator:
        """
        Regulatory compliance validation engine

        Features:
        - Position size limits
        - Sector concentration limits
        - Liquidity requirements
        - Leverage constraints
        - VaR limits
        """

        def __init__(self):
            """Initialize regulatory constraints"""
            self.constraints = {
                'max_single_position': 0.10,  # 10% max per position
                'max_sector_exposure': 0.25,  # 25% max per sector
                'min_liquidity_ratio': 0.15,  # 15% minimum liquid assets
                'max_leverage': 2.0,          # 2x maximum leverage
                'var_limit': 0.05             # 5% VaR limit
            }

        def validate_allocation(self, weights, asset_metadata):
            """
            Validate allocation against regulatory constraints

            Args:
                weights (np.array): Portfolio weights
                asset_metadata (pd.DataFrame): Asset metadata with sectors

            Returns:
                tuple: (is_compliant, violations_list)
            """
            violations = []

            # Single position limits
            max_weight = np.max(weights)
            if max_weight > self.constraints['max_single_position']:
                violations.append(f"Single position limit exceeded: {max_weight:.2%}")

            # Sector concentration
            if 'sector' in asset_metadata.columns:
                sector_exposure = asset_metadata.groupby('sector').apply(
                    lambda x: weights[x.index].sum()
                )
                max_sector = sector_exposure.max()
                if max_sector > self.constraints['max_sector_exposure']:
                    violations.append(f"Sector concentration exceeded: {max_sector:.2%}")

            return len(violations) == 0, violations

    class ScenarioAnalyzer:
        """
        Scenario analysis and stress testing engine

        Features:
        - Multi-scenario stress testing
        - Maximum drawdown calculation
        - VaR computation
        - Performance attribution
        """

        def __init__(self, returns_data):
            """
            Initialize scenario analyzer

            Args:
                returns_data (pd.DataFrame): Historical returns data
            """
            self.returns = returns_data

        def stress_test(self, weights, scenarios):
            """
            Perform stress testing under various scenarios

            Args:
                weights (np.array): Portfolio weights
                scenarios (dict): Scenario definitions with shock factors

            Returns:
                dict: Stress test results for each scenario
            """
            results = {}

            for scenario_name, shock_factors in scenarios.items():
                # Apply shocks to returns
                shocked_returns = self.returns.copy()
                for asset, shock in shock_factors.items():
                    if asset in shocked_returns.columns:
                        shocked_returns[asset] *= (1 + shock)

                # Calculate portfolio performance
                portfolio_returns = (shocked_returns * weights).sum(axis=1)
                results[scenario_name] = {
                    'total_return': portfolio_returns.sum(),
                    'volatility': portfolio_returns.std(),
                    'max_drawdown': self._calculate_max_drawdown(portfolio_returns),
                    'var_95': np.percentile(portfolio_returns, 5)
                }

            return results

        def _calculate_max_drawdown(self, returns):
            """
            Calculate maximum drawdown

            Args:
                returns (pd.Series): Portfolio returns

            Returns:
                float: Maximum drawdown value
            """
            cumulative = (1 + returns).cumprod()
            running_max = cumulative.expanding().max()
            drawdown = (cumulative - running_max) / running_max
            return drawdown.min()

    def create_capital_allocation_insights(returns_data, asset_metadata=None, scenarios=None):
        """
        Main integration function for capital allocation insights

        This function combines portfolio optimization, regulatory validation,
        and scenario analysis to provide comprehensive capital allocation insights.

        Args:
            returns_data (pd.DataFrame): Historical returns data for assets
            asset_metadata (pd.DataFrame, optional): Asset metadata including sectors
            scenarios (dict, optional): Custom stress test scenarios

        Returns:
            dict: Comprehensive capital allocation insights including:
                - optimal_weights: Optimized portfolio weights
                - efficient_frontier: Risk-return frontier data
                - performance_metrics: Expected return, volatility, Sharpe ratio
                - regulatory_compliance: Compliance status and violations
                - stress_test_results: Scenario analysis results
                - recommendations: Implementation recommendations
        """
        # Initialize components
        optimizer = PortfolioOptimizer(returns_data)
        validator = RegulatoryConstraintValidator()
        analyzer = ScenarioAnalyzer(returns_data)

        # Calculate efficient frontier
        frontier = optimizer.efficient_frontier()

        # Find optimal portfolio (max Sharpe ratio)
        optimal_weights = optimizer.optimize_portfolio()

        # Validate regulatory compliance
        is_compliant, violations = validator.validate_allocation(
            optimal_weights, asset_metadata or pd.DataFrame()
        )

        # Perform scenario analysis
        default_scenarios = {
            'market_crash': {asset: -0.30 for asset in returns_data.columns},
            'interest_rate_shock': {asset: -0.15 for asset in returns_data.columns[:len(returns_data.columns)//2]},
            'sector_rotation': {asset: 0.10 if i % 2 == 0 else -0.10 
                              for i, asset in enumerate(returns_data.columns)}
        }
        stress_results = analyzer.stress_test(optimal_weights, scenarios or default_scenarios)

        # Performance metrics
        portfolio_return = np.dot(optimal_weights, optimizer.mean_returns)
        portfolio_risk = np.sqrt(np.dot(optimal_weights.T, np.dot(optimizer.cov_matrix, optimal_weights)))
        sharpe_ratio = (portfolio_return - optimizer.risk_free_rate) / portfolio_risk

        return {
            'optimal_weights': optimal_weights,
            'efficient_frontier': frontier,
            'performance_metrics': {
                'expected_return': portfolio_return,
                'volatility': portfolio_risk,
                'sharpe_ratio': sharpe_ratio
            },
            'regulatory_compliance': {
                'is_compliant': is_compliant,
                'violations': violations
            },
            'stress_test_results': stress_results,
            'recommendations': {
                'rebalance_frequency': 'Monthly',
                'risk_monitoring': 'Daily VaR calculation',
                'compliance_review': 'Weekly constraint validation'
            }
        }

    return create_capital_allocation_insights

# ============================================================================
# END OF FUNCTION IMPLEMENTATION
# ============================================================================
